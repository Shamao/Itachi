# Canvas 绘制文字的方式

- drawText
- drawTextRun
- drawTextOnPath

## drawText

这里需要注意的是 绘制文字的坐标 并不是文字的左上角，而是如下所示。

[![drawText](https://github.com/BoBoMEe/HenCoderLearn/raw/master/images/drawText.png)](https://github.com/BoBoMEe/HenCoderLearn/blob/master/images/drawText.png)

其中 y 是baseline， 而 x 是包含了文字左边留出的空隙。

## drawTextRun

几乎用不到。

## drawTextOnPath

沿着一条 Path 来绘制文字。

> 需要注意：rawTextOnPath() 使用的 Path ，拐弯处全用圆角，别用尖角。

## StaticLayout

Canvas.drawText() 只能绘制单行的文字，而不能换行。

- 长文本在绘制边缘没有换行
- 不能在 \n 处换行

解决办法： 使用StaticLayout来绘制。

# Paint

Paint 对文字绘制的辅助，有两类方法：设置显示效果，测量文字尺寸。

## 设置显示效果

- setTextSize 设置文字大小
- setTypeface 设置字体
- setFakeBoldText 是否使用伪粗体
- setStrikeThruText 是否加删除线
- setUnderlineText 是否加下划线
- setTextSkewX 设置文字横向错切角度
- setTextScaleX 设置文字横向放缩
- setLetterSpacing 设置字符间距。默认值是 0
- setFontFeatureSettings 用 CSS 的 font-feature-settings 的方式来设置文字
- setTextAlign 设置文字的对齐方式
- setTextLocale 设置绘制所使用的 Locale
- setHinting 设置是否启用字体的 hinting
- setSubpixelText 是否开启次像素级的抗锯齿

## 测量文字尺寸类

- getFontSpacing 获取推荐的行距
- getFontMetrics 获取 Paint 的 FontMetrics， 其中包含几个文字排版方面的属性值：ascent, descent, top, bottom, leading。
- getTextBounds 获取文字的显示范围
- measureText 测量文字的宽度并返回，比 getTextBounds 大（ 和 上面 y 的值是一个原因 ）
- getTextWidths(String text, float[] widths) 获取字符串中每个字符的宽度，并把结果填入参数 widths。 和分别调用 measureText 类似
- breakText 用来测量文字宽度的，和 measureText() 的区别是breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字
- 光标相关



#### Canvas 的使用

# 范围裁切

分为`clipRect()` 和 `clipPath()`,裁切方法之后的绘制代码，都会被限制在裁切范围内。

## clipRect

注意：及时`Canvas.save()` 和 `Canvas.restore()` 来保存和恢复绘制范围。

## clipPath

将`Rect`换成了 `Path`，能裁切的形状更多

# 几何变换

- Canvas 二维变化
- Matrix 二维变换
- Camera 三维变换

## Canvas

- Canvas.translate
- Canvas.rotate
- Canvas.scale
- Canvas.skew

## Matrix

### 一般变换：

1. 创建 Matrix
2. pre/postTranslate/Rotate/Scale/Skew:设置几何变换
3. Canvas.setMatrix(matrix)/Canvas.concat(matrix):把 `Matrix` 应用到 `Canvas`

> setMatrix 是用新的 `Matrix` 直接替换 `Canvas` 当前的变换矩阵 concat 基于 Canvas 当前的变换，叠加上 Matrix 中的变换

### 自定义变换

使用方法：Matrix.setPolyToPoly，多点映射来直接设置变换，让绘制内容任意地扭曲。

## Camera

- 旋转
- 平移
- 移动相机

### 旋转

> 需要注意的是，相机的操作都是基于原点的，因此需要操作对称需要配合 `Canvas.translate()` Canvas 的几何变换顺序是反的,把移动到中心的代码写在下面，把从中心移动回来的代码写在上面.

### 平移

使用的是 `Camera.translate`

### 移动相机

使用的是 `Camera.setLocation`,可以避免「糊脸」效果

> 需要注意的是，这里的参数是 inch Camera中，相机的默认位置是 `(0, 0, -8)(英寸)`，即 `(0, 0, -576)（像素)`





#### 绘制顺序

- onDraw()
- dispatchDraw()
- 绘制过程
- onDrawForeground()
- draw()
- 注意事项
- 总结

## onDraw

> super.onDraw() 前 or 后？

1. 如果继承 `View` ， 则 `绘制代码` 写在 `前面和后面` 都无所谓，因为 `View.onDraw` 是 空实现。
2. 如果是继承 已有控件，则需要考虑 `绘制顺序` 了

- 写在 `super.onDraw()` 的下面: 绘制内容就会盖住控件原来的内容。
- 写在 `super.onDraw()` 的上面: 绘制的内容会被控件的原内容盖住。

## dispatchDraw

> 用于 `绘制子 View`，一般只对 `ViewGroup` 起作用。

- 写在 super.dispatchDraw() 的下面： `绘制` 发生在 `子View 的绘制之后`，从而让绘制内容盖住子 View 了。
- 写在 super.dispatchDraw() 的上面： 绘制就在 `onDraw() 之后`、 `super.dispatchDraw() 之前`发生，`子view` 会覆盖 `绘制内容`。

## 绘制过程

一个完整的绘制过程一般包括如下几个方面：

- 背景(drawBackground())
- 主体（onDraw()）
- 子 View（dispatchDraw()）
- 滑动边缘渐变和滑动条
- 前景

> 前景的支持是在 `Android 6.0（也就是 API 23` 才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。

具体可以看下面这张图：

[![img](https://github.com/BoBoMEe/HenCoderLearn/raw/master/images/draw_order.jpeg)](https://github.com/BoBoMEe/HenCoderLearn/blob/master/images/draw_order.jpeg)

### 滑动边缘渐变和滑动条

- android:scrollbarXXX
- View.setXXXScrollbarXXX()

### 前景

- android:foreground
- View.setForeground()

## onDrawForeground()

> 通过 `顺序` 来控制 `绘制覆盖关系` `API 23` 才引入 会依次绘制 `滑动边缘渐变`、`滑动条` 和 `前景`.

- 写在 super.onDrawForeground() 的下面: 绘制内容将会盖住滑动边缘渐变、滑动条和前景
- 写在 super.onDrawForeground() 的上面: 绘制内容会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住,
  和 写在 super.dispatchDraw() 的下面的效果是一样的
- 滑动边缘渐变、滑动条和前景是 被一起写进了 onDrawForeground() 方法里的，没法在之间绘制内容

## draw()

```
// View.java 的 draw() 方法的简化版大致结构（是大致结构，不是源码哦）：

public void draw(Canvas canvas) {
    ...

    drawBackground(Canvas); // 绘制背景（不能重写）
    onDraw(Canvas); // 绘制主体
    dispatchDraw(Canvas); // 绘制子 View
    onDrawForeground(Canvas); // 绘制滑动相关和前景

    ...
}
```

> `后面绘制的内容` 会覆盖 `前面的内容`。

### 写在 super.draw() 的下面

> 和 重写 `onDrawForeground()`，并将 绘制 写在 `super.onDrawForeground()` 之后效果一致。

### 写在 super.draw() 的上面

> 会在其他所有绘制之前被执行,绘制内容会被其他所有的内容盖住.

> 使用场景，就是 给 `EditText` 绘制背景。

## 注意事项

1. 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)；
2. 在重写的方法有多个选择时，优先选择 onDraw()。
**HenCoder Plus** 第 **8** 课 讲义 属性动画和硬件加速 



**ViewPropertyAnimator** 

使⽤用 View.animate() 创建对象，以及使⽤用 ViewPropertyAnimator.translationX() 等⽅方法 来设置动画; 

可以连续调⽤用来设置多个动画;
 可以⽤用 setDuration() 来设置持续时间; 可以⽤用 setStartDelay() 来设置开始延时; 以及其他⼀一些便便捷⽅方法。 

**ObjectAnimator** 

使⽤用 ObjectAnimator.ofXxx() 来创建对象，以及使⽤用 ObjectAnimator.start() 来主动启动 动画。它的优势在于，可以为⾃自定义属性设置动画。 

另外，⾃自定义属性需要设置 getter 和 setter ⽅方法，并且 setter ⽅方法⾥里里需要调⽤用 invalidate() 来 触发重绘: 

```
ObjectAnimator animator = ObjectAnimator.ofObject(view, "radius",
Utils.dp2px(200));
public float getRadius() {
    return radius;
```

} 

```
public void setRadius(float radius) {
    this.radius = radius;
    invalidate();
```

} 

可以使⽤用 setDuration() 来设置持续时间; 可以⽤用 setStartDelay() 来设置开始延时; 以及其他⼀一些便便捷⽅方法。 

**Interpolator** 

扔物线学堂 / rengwuxian.com 1 

插值器器，⽤用于设置时间完成度到动画完成度的计算公式，直⽩白地说即设置动画的速度曲线，通过 setInterpolator(Interpolator) ⽅方法来设置。 

常⽤用的有 AccelerateDecelerateInterpolator AccelerateInterpolator DecelerateInterpolator LinearInterpolator 。 

**PropertyValuesHolder** 

```
⽤用于设置更更加详细的动画，例例如多个属性应⽤用于同⼀一个对象:
PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat("radius",
Utils.dp2px(200));
PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat("offset",
Utils.dp2px(100));
ObjectAnimator animator = PropertyValuesHolder.ofPropertyValuesHolder(view,
holder1, holder2);
```

或者，配合使⽤用 Keyframe ，对⼀一个属性分多个段: 

```
Keyframe keyframe1 = Keyframe.ofFloat(0, Utils.dpToPixel(100));
Keyframe keyframe2 = Keyframe.ofFloat(0.5f, Utils.dpToPixel(250));
Keyframe keyframe3 = Keyframe.ofFloat(1, Utils.dpToPixel(200));
PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe("radius",
keyframe1, keyframe2, keyframe3);
ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view,
holder);
```

**AnimatorSet** 

将多个 Animator 合并在⼀一起使⽤用，先后顺序或并列列顺序都可以: 

**TypeEvaluator** 

⽤用于设置动画完成度到属性具体值的计算公式。默认的 ofInt() ofFloat() 已经有了了⾃自带的 IntEvaluator FloatEvaluator ，但有的时候需要⾃自⼰己设置 Evaluator。例例如，对于颜⾊色，需要 

为 int 类型的颜⾊色设置 ArgbEvaluator，⽽而不不是让它们使⽤用 IntEvaluator: animator.setEvaluator(new ArgbEvaluator()); 

如果你对 ArgbEvaluator 的效果不不满意，也可以⾃自⼰己写⼀一个 HsvEvaluator : 

```
AnimatorSet animatorSet = new AnimatorSet();
        animatorSet.playTogether(animator1, animator2);
        animatorSet.start();
```



```
public class HsvEvaluator implements TypeEvaluator<Integer> {
    @Override
    public Object evaluate(float fraction, Object startValue, Object
endValue) {
```

... } 

} 

另外，对于不不⽀支持的类型，也可以使⽤用 ofObject() 来在创建 Animator 的同时就设置上 Evaluator，⽐比如 NameEvaluator : 

```
public class NameEvaluator implements TypeEvaluator<String> {
    List<String> names = ...;
```

@Override 

```
    public String evaluate(float fraction, String startValue, String
endValue) {
        if (!names.contains(startValue)) {
            throw new IllegalArgumentException("Start value not existed");
        }
        if (!names.contains(endValue)) {
            throw new IllegalArgumentException("End value not existed");
        }
        int index = (int) ((names.indexOf(endValue) -
names.indexOf(startValue)) * fraction);
        return names.get(index);
    }
```

} 

```
ObjectAnimator animator = ObjectAnimator.ofObject(view, "name", new
NameEvaluator(), "Jack");
```

**Listeners** 

和 View 的点击、⻓长按监听器器⼀一样，Animator 也可以使⽤用 setXxxListener() addXxxListener() 来设置监听器器。 

**ValueAnimator** 

这是最基本的 Animator，它不不和具体的某个对象联动，⽽而是直接对两个数值进⾏行行渐变计算。使⽤用很 少。 

硬件加速 硬件加速是什什么 

使⽤用 CPU 绘制到 Bitmap，然后把 Bitmap 贴到屏幕，就是软件绘制;
 使⽤用 CPU 把绘制内容转换成 GPU 操作，交给 GPU，由 GPU 负责真正的绘制，就叫硬件绘制; 



使⽤用 GPU 绘制就叫做硬件加速 怎么就加速了了? 

GPU 分摊了了⼯工作
 GPU 绘制简单图形(例例如⽅方形、圆形、直线)在硬件设计上具有先天优势，会更更快 流程得到优化(重绘流程涉及的内容更更少) 

硬件加速的缺陷: 

兼容性。由于使⽤用 GPU 的绘制(暂时)⽆无法完成某些绘制，因此对于⼀一些特定的 API，需要关闭硬件 加速来转回到使⽤用 CPU 进⾏行行绘制。 

离屏缓冲: 

离屏缓冲是什什么:单独的⼀一个绘制 View(或 View 的⼀一部分)的区域 setLayerType() 和 saveLayer() 

setLayerType() 是对整个 View，不不能针对 onDraw() ⾥里里⾯面的某⼀一具体过程 

这个⽅方法常⽤用来关闭硬件加速，但它的定位和定义都不不只是⼀一个「硬件加速开关」。 它的作⽤用是为绘制设置⼀一个离屏缓冲，让后⾯面的绘制都单独写在这个离屏缓冲内。如 果参数填写 LAYER_TYPE_SOFTWARE ，会把离屏缓冲设置为⼀一个 Bitmap ，即使⽤用 软件绘制来进⾏行行缓冲，这样就导致在设置离屏缓冲的同时，将硬件加速关闭了了。但需 要知道，这个⽅方法被⽤用来关闭硬件加速，只是因为 Android 并没有提供⼀一个便便捷的⽅方 法在 View 级别简单地开关硬件加速⽽而已。 

saveLayer() 是针对 Canvas 的，所以在 onDraw() ⾥里里可以使⽤用 saveLayer() 来圈出具体哪部 分绘制要⽤用离屏缓冲 

然⽽而......最新的⽂文档表示这个⽅方法太重了了，能不不⽤用就别⽤用，尽量量⽤用 setLayerType() 代 替 
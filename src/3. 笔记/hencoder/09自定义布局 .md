⾃自定义布局 

布局过程 

确定每个 View 的位置和尺⼨寸 作⽤用:为绘制和触摸范围做⽀支持 

```
     绘制:知道往哪⾥里里绘制
     触摸反馈:知道⽤用户点的是哪⾥里里
```

流程 

从整体看: 

测量量流程:从根 View 递归调⽤用每⼀一级⼦子 View 的 measure() ⽅方法，对它们进⾏行行测量量 布局流程:从根 View 递归调⽤用每⼀一级⼦子 View 的 layout() ⽅方法，把测量量过程得出的⼦子 View 的位置和尺⼨寸传给⼦子 View，⼦子 View 保存
 为什什么要分两个流程? 

从个体看，对于每个 View: 

1. 运⾏行行前，开发者在 xml ⽂文件⾥里里写⼊入对 View 的布局要求 layout_xxx 

2. ⽗父 View 在⾃自⼰己的 onMeasure() 中，根据开发者在 xml 中写的对⼦子 View 的要求，和⾃自⼰己 的可⽤用空间，得出对⼦子 View 的具体尺⼨寸要求 

3. ⼦子 View 在⾃自⼰己的 onMeasure() 中，根据⾃自⼰己的特性算出⾃自⼰己的期望尺⼨寸 如果是 ViewGroup，还会在这⾥里里调⽤用每个⼦子 View 的 measure() 进⾏行行测量量 

4. ⽗父 View 在⼦子 View 计算出期望尺⼨寸后，得出⼦子 View 的实际尺⼨寸和位置 

5. ⼦子 View 在⾃自⼰己的 layout() ⽅方法中，将⽗父 View 传进来的⾃自⼰己的实际尺⼨寸和位置保存 

   如果是 ViewGroup，还会在 onLayout() ⾥里里调⽤用每个字 View 的 layout() 把它们的尺⼨寸 位置传给它们 

具体开发 

继承已有的 View，简单改写它们的尺⼨寸:重写 onMeasure():SquareImageView 

\1. 重写 onMeasure()
 \2. ⽤用 getMeasuredWidth() 和 getMeasuredSize() 获取到测量量出的尺⼨寸 3. 计算出最终要的尺⼨寸
 \4. ⽤用 setMeasuredDimension(width, height) 把结果保存 

扔物线学堂 / rengwuxian.com 1 

```
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int width = getMeasuredWidth();
    int height = getMeasuredHeight();
    int size = Math.min(width, height);
    setMeasuredDimension(size, size);
}
```

对⾃自定义 View 完全进⾏行行⾃自定义尺⼨寸计算:重写 onMeasure():CircleView 1. 重写 onMeasure()
 \2. 计算出⾃自⼰己的尺⼨寸
 \3. ⽤用 resolveSize() 或者 resolveSizeAndState() 修正结果 

resolveSize() / resolveSizeAndState() 内部实现(⼀一定读⼀一下代码，这个极少需要⾃自 ⼰己写，但⾯面试时很多时候会考): 

⾸首先⽤用 MeasureSpec.getMode(measureSpec) 和 MeasureSpec.getSize(measureSpec) 取出⽗父 对⾃自⼰己的尺⼨寸限制类型和具体限制 尺⼨寸; 

如果 measure spec 的 mode 是 EXACTLY，表示⽗父 View 对⼦子 View 的尺⼨寸做出 了了精确限制，所以就放弃计算出的 size，直接选⽤用 measure spec 的 size; 

如果 measure spec 的 mode 是 AT_MOST，表示⽗父 View 对⼦子 View 的尺⼨寸只限 制了了上限，需要看情况: 

如果计算出的 size 不不⼤大于 spec 中限制的 size，表示尺⼨寸没有超出限制，所 以选⽤用计算出的 size;
 ⽽而如果计算出的 size ⼤大于 spec 中限制的 size，表示尺⼨寸超限了了，所以选⽤用 spec 的 size，并且在 resolveSizeAndState() 中会添加标志 MEASURED_STATE_TOO_SMALL(这个标志可以辅助⽗父 View 做测量量和布 局的计算; 

如果 measure spec 的 mode 是 UNSPECIFIED，表示⽗父 View 对⼦子 View 没有任 何尺⼨寸限制，所以直接选⽤用计算出的 size，忽略略 spec 中的 size。 

\4. 使⽤用 setMeasuredDimension(width, height) 保存结果 

```
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int width = (int) ((PADDING + RADIUS) * 2);
    int height = (int) ((PADDING + RADIUS) * 2);
    setMeasuredDimension(resolveSizeAndState(width, widthMeasureSpec,
0),
```

} 

```
resolveSizeAndState(height, heightMeasureSpec, 0));
```

⾃自定义 Layout:重写 onMeasure() 和 onLayout():TagLayout 1. 重写 onMeasure() 

扔物线学堂 / rengwuxian.com 2 

\1. 遍历每个⼦子 View，⽤用 measureChildWidthMargins() 测量量⼦子 View 

需要重写 generateLayoutParams() 并返回 MarginLayoutParams 才能使⽤用 measureChildWithMargins() ⽅方法
 有些⼦子 View 可能需要重新测量量(⽐比如换⾏行行处)
 测量量完成后，得出⼦子 View 的实际位置和尺⼨寸，并暂时保存 

```
protected void onMeasure(int widthMeasureSpec, int
heightMeasureSpec) {
```

for (int i = 0; i < getChildCount(); i++) {
 View child = getChildAt(i);
 Rect childBounds = childrenBounds[i];
 // 测量量⼦子 View
 measureChildWithMargins(child, widthMeasureSpec, 

widthUsed, 

heightMeasureSpec, heightUsed); // 保存⼦子 View 的位置和尺⼨寸 

```
        childBounds.set(childlLeft, childTop, childLeft
                + child.getMeasuredWidth(), chiltTop
                + child.getMeasuredHeight());
```

...... } 

// 计算⾃自⼰己的尺⼨寸，并保存
 int width = ...;
 int height = ...; setMeasuredDimension(resolveSizeAndState(width, 

```
widthMeasureSpec, 0),
            resolveSizeAndState(height,  heightMeasureSpec,
```

0)); } 

measureChildWidthMargins() 的内部实现(最好读⼀一下代码，这个极少需要⾃自 ⼰己写，但⾯面试时很多时候会考): 

通过 getChildMeasureSpec(int spec, int padding, int childDimension) ⽅方 法计算出⼦子 View 的 widthMeasureSpec 和 heightMeasureSpec，然后调 ⽤用 child.measure() ⽅方法来让⼦子 View ⾃自我测量量; 

// ViewGroup.measureChildWithMargins() 源码 protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, 

```
        int parentHeightMeasureSpec, int heightUsed) {
    final MarginLayoutParams lp =
            (MarginLayoutParams) child.getLayoutParams();
    final int childWidthMeasureSpec =
            getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight + lp.leftMargin
```

扔物线学堂 / rengwuxian.com 3 

```
            + lp.rightMargin + widthUsed, lp.width);
    final int childHeightMeasureSpec =
            getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom + lp.topMargin
            + lp.bottomMargin + heightUsed, lp.height);
    child.measure(childWidthMeasureSpec,
childHeightMeasureSpec);
}
```

getChildMeasureSpec(int spec, int padding, int childDimension) ⽅方法的内部 实现是，结合开发者设置的 LayoutParams 中的 width 和 height 与⽗父 View ⾃自 ⼰己的剩余可⽤用空间，综合得出⼦子 View 的尺⼨寸限制，并使⽤用 MeasureSpec.makeMeasureSpec(size, mode) 来求得结果: 

// ViewGroup.getChildMeasureSpec() 源码
 public static int getChildMeasureSpec(int spec, int padding, 

```
        int childDimension) {
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch (specMode) {
    // Parent has imposed an exact size on us
    case MeasureSpec.EXACTLY:
        if (childDimension >= 0) {
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension ==
LayoutParams.MATCH_PARENT) {
            // Child wants to be our size. So be it.
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension ==
LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It
```

can't be 

```
// bigger than us.
resultSize = size;
        resultMode = MeasureSpec.AT_MOST;
    }
    break;
// Parent has imposed a maximum size on us
```

扔物线学堂 / rengwuxian.com 4 

```
    case MeasureSpec.AT_MOST:
        if (childDimension >= 0) {
            // Child wants a specific size... so be it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension ==
LayoutParams.MATCH_PARENT) {
            // Child wants to be our size, but our size is
```

not fixed. 

can't be 

it 

```
    // Child wants a specific size... let him have
    resultSize = childDimension;
    resultMode = MeasureSpec.EXACTLY;
} else if (childDimension ==
// Constrain child to not be bigger than us.
resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension ==
LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It
// bigger than us.
resultSize = size;
        resultMode = MeasureSpec.AT_MOST;
    }
```

break; 

```
// Parent asked to see how big we want to be
case MeasureSpec.UNSPECIFIED:
    if (childDimension >= 0) {
LayoutParams.MATCH_PARENT) {
            // Child wants to be our size... find out how
big it should
            // be
            resultSize =
View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        } else if (childDimension ==
LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size....
find out how
            // big it should be
            resultSize =
View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
```

break; } 

```
    //noinspection ResourceType
```

扔物线学堂 / rengwuxian.com 5 

```
    return MeasureSpec.makeMeasureSpec(resultSize,
resultMode);
```

} 

注意:源码中的分类⽅方式是先⽐比较⾃自⼰己的 MeasureSpec 中的 mode，再 ⽐比较开发者设置的 layout_width 和 layout_height，⽽而我给出的判断⽅方式 (下⾯面的这⼏几段内容)是先⽐比较 layout_width 和 layout_height，再⽐比较 ⾃自⼰己 MeasureSpec 中的 mode。两种分类⽅方法都能得出正确的结果，但 源码中的分类⽅方法在逻辑上可能不不够直观，如果你读源码理理解困难，可以 尝试⽤用我上⾯面的这种⽅方法来理理解。 

\1. 如果开发者写了了具体值(例例如 layout_width="24dp")，就不不⽤用再考虑⽗父 View 的剩余空间了了，直接⽤用 LayoutParams.width / height 来作为⼦子 View 的限制 size，⽽而限制 mode 为 EXACTLY(为什什么?课堂上说过，因为软件 的直接开发者——即 xml 布局⽂文件的编写者——的意⻅见最重要，发⽣生冲突 的时候应该以开发者的意⻅见为准。换个⻆角度说，如果真的由于冲突导致界⾯面 不不正确，开发者可以通过修改 xml ⽂文件来解决啊，所以开发者的意⻅见是第 ⼀一位，但你如果设计成冲突时开发者的意⻅见不不在第⼀一位，就会导致软件的可 配置性严重降低); 

1. 如果开发者写的是 MATCH_PARENT，即要求填满⽗父控件的可⽤用空间，那么 由于⾃自⼰己的可⽤用空间和⾃自⼰己的两个 MeasureSpec 有关，所以需要根据⾃自⼰己 的 widthMeasureSpec 或 heightMeasureSpec 中的 mode 来分情况判 断: 
   1. 如果⾃自⼰己的 spec 中的 mode 是 EXACTLY 或者 AT_MOST，说明⾃自⼰己 的尺⼨寸有上限，那么把 spec 中的 size 减去⾃自⼰己的已⽤用宽度或⾼高度， 就是⾃自⼰己可以给⼦子 View 的 size;⾄至于 mode，就⽤用 EXACTLY(注 意:就算⾃自⼰己的 mode 是 AT_MOST，传给⼦子 View 的也是 EXACTLY，想不不通的话好好琢磨⼀一下); 
   2. 如果⾃自⼰己的 spec 中的 mode 是 UNSPECIFIED，说明⾃自⼰己的尺⼨寸没有 上限，那么让⼦子 View 填满⾃自⼰己的可⽤用空间就⽆无从说起，因此选⽤用退让 ⽅方案:给⼦子 View 限制的 mode 就设置为 UNSPECIFIED，size 写 0 就 好; 
2. 如果开发者写的是 WRAP_CONTENT，即要求⼦子 View 在不不超限制的前提下 ⾃自我测量量，那么同样由于⾃自⼰己的可⽤用空间和⾃自⼰己的两个 MeasureSpec 有 关，所以也需要根据⾃自⼰己的 widthMeasureSpec 和 heightMeasureSpec 中的 mode 来分情况判断: 
   1. 如果⾃自⼰己的 spec 中的 mode 是 EXACTLY 或者 AT_MOST，说明⾃自⼰己 的尺⼨寸有上限，那么把 spec 中的 size 减去⾃自⼰己的已⽤用宽度或⾼高度， 就是⾃自⼰己可以给⼦子 View 的尺⼨寸上限;⾄至于 mode，就⽤用 AT_MOST(注意，就算⾃自⼰己的 mode 是 EXACTLY，传给⼦子 View 的也 是 AT_MOST，想不不通的话好好琢磨⼀一下; 
   2. 如果⾃自⼰己的 spec 中的 mode 是 UNSPECIFIED，说明⾃自⼰己的尺⼨寸没有 上限，那么也就不不必限制⼦子 View 的上限，因此给⼦子 View 限制的 mode 就设置为 UNSPECIFIED，size 写 0 就好。 

\2. 测量量出所有⼦子 View 的位置和尺⼨寸后，计算出⾃自⼰己的尺⼨寸，并⽤用 setMeasuredDimension(width, height) 保存 

扔物线学堂 / rengwuxian.com 6 

\2. 重写 onLayout()
 遍历每个⼦子 View，调⽤用它们的 layout() ⽅方法来将位置和尺⼨寸传给它们 
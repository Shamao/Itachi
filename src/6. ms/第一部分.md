##    1. Android类加载器

- 基于Android系统的类加载器ClassLoader
- Android平台上虚拟机运行的是Dex字节码，一种对class文件优化的产物
  - dex文件: Dex 文件是很多 .class 文件处理后的产物，最终可以在 Android 运行时环境执
  - 优点 压缩空间, 消耗内存小
- 类加载器有两种，DexClassLoader和PathClassLoader,
  - 继承于BaseDexClassLoade
  - 区别在于调用父类构造器时，
    - DexClassLoader多传了一个optimizedDirectory参数,这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。
    - PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。





## apk 启动流程

https://cloud.tencent.com/developer/article/1356506

​	

1.点击app图标，Launcher进程使用Binder IPC向system__server进程发起startActivity请求；
2.system__server进程收到1中的请求后，向zygote进程发送创建新进程的请求；
3.zygote进程fork出新的App进程
4.App进程通过Binder IPC向system__server进程发起attachApplication请求；
5.system__server进程收到4中的请求后，通过Binder IPC向App进程发送scheduleLauncherActivity请求；
6.App进程的ApplicationThread线程收到5的请求后，通过handler向主线程发送LAUNCHER_ACTIVITY消息；
7.主线程收到6中发送来的Message后，反射创建目标Activity，回调oncreate等方法，开始执行生命周期方法，我们就可以看到应用页面了。





1. 点击图标后Launcher进程会通过Binder机制向AMS发起打开Activity的请求【IPC->Binder】
2. AMS会通过ActivityStarter处理Intent和Flag(启动模式相关的内容)，然后通过Socket通知zygote进程【IPC->Socket】
3. zygote进程会进行孵化(虚拟机和资源的复制)，然后fork出新进程
4. 然后zygote进程会通过invokeDynamicMain()方法调用到ActivityThread的main方法【ActivityThread】

```
public static void main(String[] args) {
    // 1. mainLooper
    Looper.prepareMainLooper();
    // 2. 创建ActivityThread，执行attach
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    // 3. Handler
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    // 4. loop()
    Looper.loop();
}
```

1. main()中关于Handler相关的工作是：主线程Looper和Handler的创建、开启主线程Looper的消息循环
2. main()另一工作就是创建ActivityThread对象，执行attach方法。【Application、ContentProvider】

> 1. 先通过AMS执行bindApplication方法
> 2. 内部会创建属于Application的ContextImpl对象，并且创建Application对象，建立两者的联系
> 3. 创建ContentProvider，执行其onCreate()方法，并进行发布相关操作(前提是该app有ContentProvider)
> 4. 执行Application的onCreate()方法

**知识点要建立体系，上面【】部分就是扩展的点。**
比如:

1. 进程间通信IPC的Binder机制有哪些应用的场景？

2. IPC中Socket方式有哪些应用场景？

3. Application的Context上下文对象是在哪里初始化的？

4. ContentProvider是在哪里创建、初始化和发布的？

5. ContentProvider的onCreate()和Application的onCreate()方法哪个先执行？

   这些东西都能从App启动流程中找到答案，还有很多扩展的点，就不多说了。上面attach()方法的源码细节也很多，也不赘述了。



![](https://img-blog.csdn.net/20170515074139121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRXRoYW5Dbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)







线程间的同步实质是保证相城中共享变量的数据同步

1. volatile关键字，在get和set的场景下是可以的，由于get和set的时候都加了读写内存屏障，在数据可见性上保证数据同步。但是对于++这种非原子性操作，数据会出现不同步
2. synchronized对代码块或方法加锁，结合wait，notify调度保证数据同步
3. reentrantLock加锁结合Condition条件设置，在线程调度上保障数据同步
4. CountDownLatch简化版的条件锁，在线程调度上保障数据同步
5. cas=compare and swap(set), 在保证操作原子性上，确保数据同步
6. 参照UI线程更新UI的思路，使用handler把多线程的数据更新都集中在一个线程上，避免多线程出现脏读








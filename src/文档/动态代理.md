### 动态代理

#### 什么是代理

- 代为处理， 表现为替你讨课， 替你吃饭...

- 实现方式有静态代理和动态代理

#### 静态代理

- 简单来说静态代理的代码是在程序运行前生成的， 可能是程序员编写, 也有可能在编译器生成的

```java
 // 定义卖家卖橘子
interface  Saler{
    void saleOrange();
}

// 如果本体是老板， 也可以卖橘子， 但是他不想出面卖, 想找个人提
class 本体 implements Saler{
  @Override
  public void saleOrange() {
     // ... 
   }
}

// 找了小二  代替老板卖东西， 实际上还是老板卖橘子
class proxy implements Saler {
  Saler saler 
   proxy{
    saler = 本体；
  }
  
  @Override
  public void saleOrange() {
     // ... 
    saler.saleOrange() //帮本体代理了事务
   }
}
```



#### 动态代理
- 动态代理的业务代码是在程序运行时生成的代码
 

##### 1. 实现方式： 通过InvocationHandler实现动态代理
```
    public static interface Saler {
        void saleOrange();
    }

    public static class Boss implements Saler {

        @Override
        public void saleOrange() {
            System.out.println("sale orange");
        }
    }

    public static class MyInvocationHandler implements InvocationHandler {
        private Object object;

        public MyInvocationHandler(Object object) {
            this.object = object;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            method.invoke(object);
            return proxy;
        }
    }

      public static void main(String[] args) {
        Saler people = new Boss();
        //代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法
        MyInvocationHandler handler = new MyInvocationHandler(people);
        /**
         * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数
         * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象
         * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法
         * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上
         */
        Saler proxy = (Saler) Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);

        proxy.saleOrange();
    }
```


##### 2. 实现方式:  
  - JDK动态代理就是通过反射机制实现的
  - 成和转换Java字节码
    - 动态生成代理类java文件
    - 编译代理类java文件为class
    - 加载到内存
    - 关联InvocationHandler

1. 动态生成代理类java 
  - 通过JavaPoet 
   -  [JavaPoet](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fjavapoet) 可以简化我们实现生成java文件

2. ##### 编译TimeProxy源码
  
  - 通过JavaCompiler编译文件

3. 加载到内存
   - 通过classLoader 加载到内存


4. ##### 增加InvocationHandler接口

 ```public interface InvocationHandler {
   void invoke(Object proxy, Method method, Object[] args);
   }
   
   myInvocationHandler handler = new MyInvocationHandler();
   Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);
   proxy.fly();

Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird()));

 ```




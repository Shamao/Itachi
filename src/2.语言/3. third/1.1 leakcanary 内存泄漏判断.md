## 一、概述

LeakCanary 是一个内存泄漏的自动化监测工具。

### 1.1什么是内存泄漏？

内存泄漏指的是应该被释放的内存的没有被释放。原因？长生命周期的对象持有短生命周期对象的引用。

### 1.2哪些对象应该被回收？

首先要找出哪些对象是**应该被回收**的？Android 中使用最频繁的是 Activity 和 Fragment 了。他们都有 onDestory 方法，当它们的 **onDestroy 执行的时候，就可以把它们列为 「应该被回收的对象**」，可在 onDestory 方法中建立**检测点**。

注：

1. `Application#dispatchActivityDestroyed` 是在 `Activity#onDestroy` 方法执行后回调的。

### 1.3如何知道对象是否被回收了？

手动 GC +ReferenceQueue + WeakReference

> WeakReference 创建时，传入一个 ReferenceQueue 对象。当被 WeakReference 引用的对象的生命周期结束，一旦被 GC 检查到，GC 将会把该对象添加到 ReferenceQueue 中，待 ReferenceQueue 处理。当 GC 过后对象一直不被加入 ReferenceQueue，说明它可能存在内存泄漏。

这里其实有一个默认的前提就是，当一个对象存在强引用的时候，这个对象是不会被回收的，所以 GC 前后，可达性并不会发生变化，也就不会被加入到 referenceQueue 中。而如果一个对象只含有弱引用的时候，GC 前后可达性会发生改变——GC 之前弱可达，GC 之后变不可达。

什么样的对象会进入ReferenceQueue？

> 创建 Reference 的时候指定了 ReferenceQueue，并且对象的可达性发生了变化。

具体加入的时间是在 GC前还是 GC后 并不是很重要，重要的是，**一旦被添加到 ReferenceQueue 中，对应的对象一定会被回收** (及时被回收了自然也就没有内存泄漏问题了，所以 LeakCanary 把加入 ReferenceQueue 作为内存泄漏检测的初步判断标准)

假设没有发生内存泄漏，那么这个时候，Activity 仅被我们创建的 KeyedWeakReference 弱引用了。我们第一次手动 GC 的时候，它就会进入引用队列。这个时候可以将它从 retainkeys 中移除。

对象一旦只存在弱引用，会 ReferenceHandler 线程监听到，该线程会将该对象的引用加入 ReferenceQueue 中，这发生在 finalization 或者 gc 之前。

LeakCanary 判断是否发生内存的泄漏的标准：对象的引用是否在`Set<String> retainedKeys` 中。

- 创建一个跟踪对象，将它的 key 存储在一个 retainedKeys 中。当对象出现在引用队列里面的时候，将它从 set 中移除，如果一个对象的引用不在retainKeys 中，说明没有发生内存泄漏。如果在，则说明可能发生了内存泄漏。
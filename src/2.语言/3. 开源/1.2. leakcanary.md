> A memory leak detection library for Android.


#### 什么是内存泄漏 
由于疏忽或错误造成程序未能释放已经不再使用的内存。

#### 集成(1.x 版本)
1. build.gradle 添加依赖
```
dependencies {
   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5'
   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'
   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'
 }

 (以上版本不同)
```
2. application注册

```
   public class ExampleApplication extends Application {
     @Override public void onCreate() {
       super.onCreate();
       if (LeakCanary.isInAnalyzerProcess(this)) {
         // This process is dedicated to LeakCanary for heap analysis.
         // You should not init your app in this process.
         return;
       }
       LeakCanary.install(this);
       // Normal app init code...
     }
}
```

#### 分析

##### 第一步	

**1. 初始化操作**

```java
     /*
      * Application onCreate方法调用这个 
      * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
      * references (on ICS+).
      */
     public static RefWatcher install(Application application) {
       return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
           .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
           .buildAndInstall();
     }

   /**
   * Creates a {@link RefWatcher} instance and starts watching activity references (on 					 ICS+).
   */
    public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      LeakCanary.enableDisplayLeakActivity(context);
      ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher);
    }
    return refWatcher;
    }
   
```

- refWatcher 是为了构建AndroidRefWatcherBuilder

- listenerServiceClass(DisplayLeakService.class)  **用来分析最后的内存泄漏**

- excludedRefs(AndroidExcludedRefs.createAppDefaults().build())

- buildAndInstall(): 创建RefWatcher, 注册lifecycleCallbacks， 监听activity生命周期

**2.监听**

   ```java
   private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
      new Application.ActivityLifecycleCallbacks() {
      ...
        @Override public void onActivityDestroyed(Activity activity) {
        	// activity ondestory 回调后最后会调用传入的refWatcher.watch(activity);
          ActivityRefWatcher.this.onActivityDestroyed(activity); 
        }
      };
   ```

```java
/**
   * Watches the provided references and checks if it can be GCed. This method is non blocking,
   * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
   * with.
   *
   * @param referenceName An logical identifier for the watched object.
   */
  public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
      return;
    }
    checkNotNull(watchedReference, "watchedReference");
    checkNotNull(referenceName, "referenceName");
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key); // 将activity 的 key 放入retainedKeys 判断是否内存泄漏了
    // 创建引用并放入queue中
    final KeyedWeakReference reference =
        new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
  }

```

**3.异步执行ensureGone**

```
 private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
    watchExecutor.execute(new Retryable() {
      @Override public Retryable.Result run() {
        return ensureGone(reference, watchStartNanoTime);
      }
    });
  }
```

- 其中watchExecutor的示例是AndroidWatchExecutor，**refWatcher(application)**返回AndroidRefWatcherBuilder， 内部的watchExecutor示例为AndroidWatchExecutor

**4. 分析是否内存泄漏**

```java
Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    long gcStartNanoTime = System.nanoTime();
    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
		// 将已经回收的引用从retainedKeys中移除
    removeWeaklyReachableReferences();

    if (debuggerControl.isDebuggerAttached()) {
      // The debugger can create false leaks.
      return RETRY;
    }
  	// 判断当前引用是否已经被回收了， 如果已经回收了， 则结束当前流程
    // 如果没有回收， 继续下面
    if (gone(reference)) {
      return DONE;
    }
    // 进行一次手动GC， 系统回收机制可能没有扫描到没有回收该引用， 所以手动执行一次
    gcTrigger.runGc();
  	// 将已经回收的引用从retainedKeys中移除
    removeWeaklyReachableReferences();
  	// 如果此时该引用还没有被移除， 说明该引用存在内存泄漏
    if (!gone(reference)) {
      // 接下来就是打印泄漏文档
      long startDumpHeap = System.nanoTime();
      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
			// 生成 heapDumper文件
      File heapDumpFile = heapDumper.dumpHeap();
      if (heapDumpFile == RETRY_LATER) {
        // Could not dump the heap.
        return RETRY;
      }
      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
      // 通过之前传入的heapdumpListener进行分析, ServiceHeapDumpListener对象， DisplayLeakService显示分析结果
      // 
      heapdumpListener.analyze(
          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
              gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
  }
```




#### #### 到底什么是ReferenceQueue 

ReferenceQueue，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。



```java
 /**
     * Adds this reference object to the queue with which it is registered,
     * if any.
     *
     * <p> This method is invoked only by Java code; when the garbage collector
     * enqueues references it does so directly, without invoking this method.
     *
     * @return   <code>true</code> if this reference object was successfully
     *           enqueued; <code>false</code> if it was already enqueued or if
     *           it was not registered with a queue when it was created
     */
    public boolean enqueue() {
       return queue != null && queue.enqueue(this);
    }
```

```java
 private boolean enqueueLocked(Reference<? extends T> r) {
        // Verify the reference has not already been enqueued.
        if (r.queueNext != null) {
            return false;
        }

        if (r instanceof Cleaner) {
            // If this reference is a Cleaner, then simply invoke the clean method instead
            // of enqueueing it in the queue. Cleaners are associated with dummy queues that
            // are never polled and objects are never enqueued on them.
            Cleaner cl = (sun.misc.Cleaner) r;
            cl.clean();

            // Update queueNext to indicate that the reference has been
            // enqueued, but is now removed from the queue.
            r.queueNext = sQueueNextUnenqueued;
            return true;
        }

        if (tail == null) {
            head = r;
        } else {
            tail.queueNext = r;
        }
        tail = r;
        tail.queueNext = r;
        return true;
    }

```



上面代码说明当reference


#### 拓展
1. LeakCanary2 的免写 初始化代码 原理

  **解释 ： ** 通过注册LeakSentryInstaller（ContentProvider 类型）来实现在内部完成了 初始化工作，根据启动流程Application->attachBaseContext =====>ContentProvider->onCreate =====>Application->onCreate =====>Activity->onCreate




#### SharedPreferences 



#### 介绍

1. SharedPreferences是以 key-value 的方式存取数据， 轻量级， 支持booleans, floats, ints, longs, and strings.不支持对象
2. 场景： 用于存取数据量小的持久化数据



#### 使用

1.  获取SharedPreferences

   ```java
   Context context = getActivity();
   SharedPreferences sp = getSharedPreferences("fileName", Context.MODE_PRIVATE);
   ```

   

2.  写数据

   ```java
   sp.edit().putString("key", "value").commit(); // or apply
   ```

3. 读数据

    ```java
   String result = sp.getString("key", "defaultValue");
   ```


#### 源码分析

1. 获取SharedPreferences, 通过调用 **Context.getSharedPreferences(String name, @PreferencesMode int mode);**获取， 而Context 其实是ContextImpl

   ```java
    @Override
       public SharedPreferences getSharedPreferences(String name, int mode) {
           ...
   
           File file;
           synchronized (ContextImpl.class) {
               if (mSharedPrefsPaths == null) {
                   mSharedPrefsPaths = new ArrayMap<>();
               }
               file = mSharedPrefsPaths.get(name);
               if (file == null) {
                   file = getSharedPreferencesPath(name);
                   mSharedPrefsPaths.put(name, file);
               }
           }
           return getSharedPreferences(file, mode);
       }
   
   @Override
       public SharedPreferences getSharedPreferences(File file, int mode) {
           SharedPreferencesImpl sp;
           synchronized (ContextImpl.class) {
               ...
               sp = cache.get(file);
               if (sp == null) {
     							...
                   sp = new SharedPreferencesImpl(file, mode);
                   cache.put(file, sp);
                   return sp;
               }
           }
           // 获取SharedPreferencesImpl, 获取到的获取SharedPreferencesImpl会缓存在cache中
           ...
           // 如果由其他进程修改了这个 SharedPreferences 文件，我们将会重新加载它
           //  !stat.st_mtim.equals(mStatTimestamp) || mStatSize != stat.st_size;
           sp.startReloadIfChangedUnexpectedly();
           return sp;
       }
   ```

   > 可见 sdk 是先取了缓存(sSharedPrefs静态变量), 如果缓存未命中, 才构造对象. 也就是说, 多次 getSharedPreferences 几乎是没有代价的. 同时, 实例的构造被 synchronized 关键字包裹, 因此构造过程是多线程安全的

2.  创建 SharedPreferencesImpl 

   ```java
    SharedPreferencesImpl(File file, int mode) {
           mFile = file; // 数据存储文件
           mBackupFile = makeBackupFile(file);// 创建灾备文件，命名为prefsFile.getPath() + ".bak"
           mMode = mode;
           mLoaded = false; // mLoaded代表是否已经加载完数据
           mMap = null;  // 解析 xml 文件得到的键值对就存放在mMap中
           mThrowable = null;
           startLoadFromDisk(); //用于加载 mFile 这个磁盘上的 xml 文件
       }
   
    // 创建灾备文件，用于当用户写入失败的时候恢复数据
    private static File makeBackupFile(File prefsFile) {
         return new File(prefsFile.getPath() + ".bak");
    }
   
   ```

   - startLoadFromDisk

     ```java
       private void startLoadFromDisk() {
             synchronized (mLock) {
                 mLoaded = false;
             }
             new Thread("SharedPreferencesImpl-load") {
                 public void run() {
                     loadFromDisk();
                 }
             }.start();
         }
     ```
     
    - loadFromDisk()
   
      ```java
       private void loadFromDisk() {
              synchronized (mLock) {
                  if (mLoaded) { // 如果正在加载数据，直接返回
                      return;
                  }
                  // 如果备份文件存在，删除原文件，把备份文件重命名为原文件的名字
                  // 我们称这种行为叫做回滚
                  if (mBackupFile.exists()) { 
                      mFile.delete();
                      mBackupFile.renameTo(mFile);
                  }
              }
      
              // Debugging
              if (mFile.exists() && !mFile.canRead()) {
                  Log.w(TAG, "Attempt to read preferences file " + mFile + " without permission");
              }
      
              Map<String, Object> map = null;
              StructStat stat = null;
              Throwable thrown = null;
              try {
                  stat = Os.stat(mFile.getPath());  // 获取文件信息，包括文件修改时间，文件大小等
                  if (mFile.canRead()) {
                      BufferedInputStream str = null;
                      try {
                           // 读取数据并且将数据解析map
                          str = new BufferedInputStream(
                                  new FileInputStream(mFile), 16 * 1024);
                          map = (Map<String, Object>) XmlUtils.readMapXml(str);
                      } catch (Exception e) {
                          Log.w(TAG, "Cannot read " + mFile.getAbsolutePath(), e);
                      } finally {
                          IoUtils.closeQuietly(str);
                      }
                  }
              } catch (ErrnoException e) {
                  // An errno exception means the stat failed. Treat as empty/non-existing by
                  // ignoring.
              } catch (Throwable t) {
                  thrown = t;
              }
      
              synchronized (mLock) {
                	// 加载数据成功，设置 mLoaded 为 true
                  mLoaded = true;
                  mThrowable = thrown;
      
                  // It's important that we always signal waiters, even if we'll make
                  // them fail with an exception. The try-finally is pretty wide, but
                  // better safe than sorry.
                  try {
                      if (thrown == null) {
                          if (map != null) {
                              mMap = map;
                              mStatTimestamp = stat.st_mtim;
                              mStatSize = stat.st_size;
                          } else {
                              mMap = new HashMap<>();
                          }
                      }
                      // In case of a thrown exception, we retain the old map. That allows
                      // any open editors to commit and store updates.
                  } catch (Throwable t) {
                      mThrowable = t;
                  } finally {
                    // 通知唤醒所有等待的线程
                      mLock.notifyAll();
                  }
              }
          }
      ```
   
      - 如果有备份文件，直接使用备份文件进行回滚
      - 第一次调用`getSharedPreferences`方法的时候，会从磁盘中加载数据，而数据的加载时通过开启一个子线程调用`loadFromDisk`方法进行异步读取的
      - 将解析得到的键值对数据保存在`mMap`中
      - 将文件的修改时间戳以及大小分别保存在`mStatTimestamp`以及`mStatSize`中（保存这两个值有什么用呢？我们在分析`getSharedPreferences`方法时说过**sp.startReloadIfChangedUnexpectedly();**，如果有其他进程修改了文件，并且`mode`为`MODE_MULTI_PROCESS`，将会判断重新加载文件。如何判断文件是否被其他**进程**修改过，没错，根据文件修改时间以及文件大小即可知道
      - 调用`notifyAll()`方法通知唤醒其他等待线程，数据已经加载完毕
   
   3 . getXXX（） 操作
   
   ​	```
   
   ```java
   @Override
   @Nullable
   public String getString(String key, @Nullable String defValue) {
       synchronized (mLock) { // 线程安全
           awaitLoadedLocked();
           String v = (String)mMap.get(key);
           return v != null ? v : defValue;
       }
   }
   
     @GuardedBy("mLock")
       private void awaitLoadedLocked() {
           if (!mLoaded) {
               // Raise an explicit StrictMode onReadFromDisk for this
               // thread, since the real read will be in a different
               // thread and otherwise ignored by StrictMode.
               BlockGuard.getThreadPolicy().onReadFromDisk();
           }
           while (!mLoaded) {
               try {
                   mLock.wait(); // 等待数据加载完成之后才返回继续执行代码
               } catch (InterruptedException unused) {
               }
           }
           if (mThrowable != null) {
               throw new IllegalStateException(mThrowable);
           }
       }
   ```
   4. putXXX（）操作
   
    ```java
   		// putXxx/remove/clear等写操作方法都不是直接操作 mMap 的，而是将所有
       // 的写操作先记录在 mModified 中，等到 commit/apply 方法被调用，才会将
       // 所有写操作同步到 内存中的 mMap 以及磁盘中
       private final Map<String, Object> mModified = Maps.newHashMap();
       
   		@Override
       public Editor putBoolean(String key, boolean value) {
           synchronized (mEditorLock) {
             mModified.put(key, value);
             return this;
           }
       }
    ```
   
   5 . commit / apply

```java
@Override
public boolean commit() {
    long startTime = 0;

    if (DEBUG) {
        startTime = System.currentTimeMillis();
    }

    MemoryCommitResult mcr = commitToMemory();// 提交到内存

    SharedPreferencesImpl.this.enqueueDiskWrite(
        mcr, null /* sync write on this thread okay */);
    try {
        mcr.writtenToDiskLatch.await(); // 等待写文件成功后才会执行后面的
    } catch (InterruptedException e) {
        return false;
    } finally {
        if (DEBUG) {
            Log.d(TAG, mFile.getName() + ":" + mcr.memoryStateGeneration
                    + " committed after " + (System.currentTimeMillis() - startTime)
                    + " ms");
        }
    }//。提交到 文件
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
}
```

````java
 private MemoryCommitResult commitToMemory() {
            long memoryStateGeneration;
            List<String> keysModified = null;
            Set<OnSharedPreferenceChangeListener> listeners = null;
            Map<String, Object> mapToWriteToDisk;

            synchronized (SharedPreferencesImpl.this.mLock) {
                // We optimistically don't make a deep copy until
                // a memory commit comes in when we're already
                // writing to disk.
                if (mDiskWritesInFlight > 0) {
                    // We can't modify our mMap as a currently
                    // in-flight write owns it.  Clone it before
                    // modifying it.
                    // noinspection unchecked
                    mMap = new HashMap<String, Object>(mMap); // 去impl 外层的map 且 复制了
                }
               // 将 mMap 赋值给 mcr.mapToWriteToDisk，mcr.mapToWriteToDisk 指向的就是最终写入磁盘的数据
                mapToWriteToDisk = mMap;
              // mDiskWritesInFlight 代表的是“此时需要将数据写入磁盘，但还未处理或未处理完成的次数”
        			// 将 mDiskWritesInFlight 自增1（这里是唯一会增加 mDiskWritesInFlight 的地方） 
              mDiskWritesInFlight++;
              ....
                synchronized (mEditorLock) {
                boolean changesMade = false;
										// clear 只会移除原来的数据 不是移除新的数据
                    if (mClear) {
                        if (!mapToWriteToDisk.isEmpty()) {
                            changesMade = true;
                            mapToWriteToDisk.clear();
                        }
                        mClear = false;
                    }

                    for (Map.Entry<String, Object> e : mModified.entrySet()) {
                        String k = e.getKey();
                        Object v = e.getValue();
                        // "this" is the magic value for a removal mutation. In addition,
                        // setting a value to "null" for a given key is specified to be
                        // equivalent to calling remove on that key.
                        if (v == this || v == null) { // 调用了remove
                            if (!mapToWriteToDisk.containsKey(k)) {
                                continue;
                            }
                            mapToWriteToDisk.remove(k);
                        } else {// put操作 
                            if (mapToWriteToDisk.containsKey(k)) {
                                Object existingValue = mapToWriteToDisk.get(k);
                                if (existingValue != null && existingValue.equals(v)) {
                                    continue; // put的和之前是一致的就不操作了
                                }
                            }
                            mapToWriteToDisk.put(k, v); // 添加到需要写入到disk的数据
                        }

                        changesMade = true;
                        if (hasListeners) {
                            keysModified.add(k);
                        }
                    }

                    mModified.clear();

                    if (changesMade) {
                        mCurrentMemoryStateGeneration++;
                    }

                    memoryStateGeneration = mCurrentMemoryStateGeneration;
                }
            }
            return new MemoryCommitResult(memoryStateGeneration, keysModified, listeners,
                    mapToWriteToDisk);
        }
````





```java
private void enqueueDiskWrite(final MemoryCommitResult mcr,
                                  final Runnable postWriteRunnable) {
        final boolean isFromSyncCommit = (postWriteRunnable == null);

        final Runnable writeToDiskRunnable = new Runnable() {
                @Override
                public void run() {
                    synchronized (mWritingToDiskLock) {
                        writeToFile(mcr, isFromSyncCommit);
                    }
                    synchronized (mLock) {
                        mDiskWritesInFlight--;
                    }
                    if (postWriteRunnable != null) {
                    // 执行 postWriteRunnable（提示，在 apply 中，postWriteRunnable 才不为 null
                        postWriteRunnable.run();
                    }
                }
            };

        // Typical #commit() path with fewer allocations, doing a write on
        // the current thread.
        if (isFromSyncCommit) {
            boolean wasEmpty = false;
            synchronized (mLock) {
                wasEmpty = mDiskWritesInFlight == 1;
            }
            if (wasEmpty) {
                writeToDiskRunnable.run();
                return;
            }
        }

        QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);
    }
```

`writeToFile`这个方法大致分为三个过程:

- 先把已存在的老的 SP 文件重命名(加“.bak”后缀)，然后删除老的 SP 文件，这相当于做了备份（灾备）
- 向`mFile`中一次性写入所有键值对数据，即`mcr.mapToWriteToDisk`(这就是`commitToMemory`所说的保存了所有键值对数据的字段) 一次性写入到磁盘。 如果写入成功则删除备份（灾备）文件，同时记录了这次同步的时间
- 如果往磁盘写入数据失败，则删除这个半成品的 SP 文件

`apply()`方法：

- `commitToMemory()`方法将`mModified`中记录的写操作同步回写到内存 `SharedPreferences.mMap` 中。此时, 任何的`getXxx`方法都可以获取到最新数据了
- 通过`enqueueDiskWrite`方法调用`writeToFile`将方法将所有数据**异步**写入到磁盘中





#### 额外

- 通过CountDownLatch这个类来实现 `commit`操作同步， 需要额外了解
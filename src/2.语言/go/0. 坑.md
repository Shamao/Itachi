####  1. [ invalid memory address or nil pointer dereference](https://www.xiaorongmao.com/blog/83)
-  直接复制和间接赋值 ： **= 是赋值， := 是声明变量并赋值**

#### 2. 数据库模型生命的时候需要大写。兄弟啊

#### 3. 数据库连接末尾需要添加以下参数   charset=utf8&parseTime=True

#### 4.  这就要从Golang切片的扩容说起了；切片的扩容，就是当切片添加元素时，切片容量不够了，就会扩容，扩容的大小遵循下面的原则：（如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。）如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组（这就是产生bug的原因）；如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。 建议尽量避免bug的产生。





#### 1 值传递和引用传递

> 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 `return` 返回。
#### 1. **?**字符

`?` 字符代表单个字符

```shell
# 存在文件 a.txt 和 b.txt
$ ls ?.txt
a.txt b.txt
```

- 同时匹配`a.txt`和`b.txt`。

#### 2 . * 字符

`*` 代表任意数量的任意字符。

`*`  可以匹配空字符

```shell
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls *.txt
a.txt b.txt ab.txt

# 输出所有文件
$ ls *
```



#### 3. [...] 模式

`[...]` 匹配方括号之中的任意一个字符，比如`[aeiou]`可以匹配五个元音字母。

```bash
# 存在文件 a.txt 和 b.txt
$ ls [ab].txt
a.txt b.txt

$ ls *[ab].txt
ab.txt a.txt b.txt
```

`[start-end]` 表示一个连续的范围。

```bash
# 存在文件 a.txt、b.txt 和 c.txt
$ ls [a-c].txt
a.txt b.txt c.txt

# 存在文件 report1.txt、report2.txt 和 report3.txt
$ ls report[0-9].txt
report1.txt report2.txt report3.txt
```

#### 4. `[^...]` 和 `[!...]`

`[^...]`和`[!...]` 表示匹配不在方括号里面的字符（**不包括空字符**）。这两种写法是等价的。

```bash
# 存在文件 a.txt、b.txt 和 c.txt
$ ls [^a].txt
b.txt c.txt
```

这种模式下也可以使用连续范围的写法`[!start-end]`。

```bash
$ echo report[!1-3].txt
report4.txt report5.txt
```

#### 5. {...} 模式

`{...}` 表示匹配大括号里面的所有模式，模式之间使用逗号分隔   ` 注： 感觉类似或者`

```bash
$ echo d{a,e,i,u,o}g
dag deg dig dug dog
```

它可以用于多字符的模式。

  ```bash
$ echo {cat,dog}
cat dog
  ```

`{...}`与`[...]`有一个很重要的区别。如果匹配的文件不存在，`[...]`会失去模式的功能，变成一个单纯的字符串，而`{...}`依然可以展开。

```bash
# 不存在 a.txt 和 b.txt
$ ls [ab].txt
ls: [ab].txt: No such file or directory

$ ls {a,b}.txt
ls: a.txt: No such file or directory
ls: b.txt: No such file or directory
```

大括号可以嵌套。

  ```bash
$ echo {j{p,pe}g,png}
jpg jpeg png
  ```

大括号也可以与其他模式联用。

> ```bash
> $ echo {cat,d*}
> cat dawg dg dig dog doug dug
> ```

#### 6. {start..end} 模式

`{start..end}`会匹配连续范围的字符。`注： 类似正则的[a-z]`

```bash
$ echo d{a..d}g
dag dbg dcg ddg

$ echo {11..15}
11 12 13 14 15
```

如果遇到无法解释的扩展，模式会原样输出。

  ```bash
$ echo {a1..3c}
{a1..3c}
  ```

这种模式与逗号联用，可以写出复杂的模式。

> ```bash
> $ echo .{mp{3..4},m4{a,b,p,v}}
> .mp3 .mp4 .m4a .m4b .m4p .m4v
> ```

#### 7. 注意点

通配符有一些使用注意点，不可不知。

**（1）通配符是先解释，再执行。**

Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。

> ```bash
> $ ls a*.txt
> ab.txt
> ```

上面命令的执行过程是，Bash 先将`a*.txt`扩展成`ab.txt`，然后再执行`ls ab.txt`。

**（2）通配符不匹配，会原样输出。**

Bash 扩展通配符的时候，发现不存在匹配的文件，会将通配符原样输出。

> ```bash
> # 不存在 r 开头的文件名
> $ echo r*
> r*
> ```

**3）只适用于单层路径。**

上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，`?`或`*`这样的通配符，不能匹配路径分隔符（`/`）。

如果要匹配子目录里面的文件，可以写成下面这样。

> ```bash
> $ ls */*.txt
> ```

**（4）可用于文件名。**

Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。

> ```bash
> $ touch 'fo*'
> $ ls
> fo*
> ```

上面代码创建了一个`fo*`文件，这时`*`就是文件名的一部分。